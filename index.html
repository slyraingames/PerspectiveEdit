<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rune Display</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-white rounded-lg shadow-xl p-6">
        <h1 class="text-3xl font-bold text-center mb-4 text-gray-700">Rune Display Image Transformer</h1>
        <p class="text-center text-gray-500 mb-6">Upload an image to automatically apply the Rune Display perspective effect.</p>

        <div class="mb-6">
            <label for="imageUpload" class="block mb-2 text-sm font-medium text-gray-900">Upload Image</label>
            <input type="file" id="imageUpload" accept="image/*" class="block w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 cursor-pointer focus:outline-none">
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h2 class="text-xl font-semibold mb-2">Original Image</h2>
                <div id="originalContainer" class="relative border-2 border-dashed border-gray-300 rounded-lg aspect-square bg-gray-50 flex items-center justify-center">
                    <p id="originalPlaceholder" class="text-gray-400">Upload an image to begin</p>
                    <canvas id="originalCanvas" class="hidden max-w-full max-h-full"></canvas>
                </div>
            </div>
            <div>
                <h2 class="text-xl font-semibold mb-2">Transformed Image</h2>
                <div class="border-2 border-gray-300 rounded-lg aspect-square bg-gray-50 flex items-center justify-center">
                     <canvas id="transformedCanvas" class="max-w-full max-h-full"></canvas>
                </div>
                 <button id="downloadBtn" class="mt-4 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out disabled:bg-gray-400" disabled>
                    Download Image
                </button>
            </div>
        </div>
    </div>

    <script>
        // DOM element references
        const imageUpload = document.getElementById('imageUpload');
        const originalContainer = document.getElementById('originalContainer');
        const originalPlaceholder = document.getElementById('originalPlaceholder');
        const originalCanvas = document.getElementById('originalCanvas');
        const transformedCanvas = document.getElementById('transformedCanvas');
        const downloadBtn = document.getElementById('downloadBtn');
        const ctxOriginal = originalCanvas.getContext('2d');
        const ctxTransformed = transformedCanvas.getContext('2d');

        let img = new Image();
        let originalWidth, originalHeight;

        // Event listener for image upload
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    img.onload = () => {
                        originalWidth = img.width;
                        originalHeight = img.height;
                        setupCanvas();
                        draw();
                        downloadBtn.disabled = false; // Enable download button
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Event listener for the download button
        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'rune-display-image.png';
            link.href = transformedCanvas.toDataURL('image/png');
            link.click();
        });

        /**
         * Sets up the canvas dimensions.
         */
        function setupCanvas() {
            const containerWidth = originalContainer.clientWidth;
            const containerHeight = originalContainer.clientHeight;

            // Maintain aspect ratio
            let canvasWidth, canvasHeight;
            const aspectRatio = originalWidth / originalHeight;
            if (containerWidth / containerHeight > aspectRatio) {
                canvasHeight = containerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                canvasWidth = containerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            
            originalCanvas.width = canvasWidth;
            originalCanvas.height = canvasHeight;
            transformedCanvas.width = canvasWidth;
            transformedCanvas.height = canvasHeight;

            originalCanvas.style.display = 'block';
            originalCanvas.classList.remove('hidden');
            originalPlaceholder.classList.add('hidden');
        }
        
        /**
         * Main draw function to render original and transformed images.
         */
        function draw() {
            if (!img.src) return;

            // Draw original image
            ctxOriginal.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            ctxOriginal.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);

            // Draw transformed image
            applyPerspectiveTransform();
        }
        
        window.addEventListener('resize', () => {
            if (img.src) {
                setupCanvas();
                draw();
            }
        });

        /**
         * Applies the perspective transformation to the image.
         */
        function applyPerspectiveTransform() {
            const w = transformedCanvas.width;
            const h = transformedCanvas.height;
            ctxTransformed.clearRect(0, 0, w, h);

            // Source points are the corners of the original image
            const srcPoints = [
                { x: 0, y: 0 },
                { x: originalWidth, y: 0 },
                { x: 0, y: originalHeight },
                { x: originalWidth, y: originalHeight },
            ];
            
            // Destination points are hardcoded to create the desired perspective
            const dstPoints = [
                { x: w * 0.15, y: h * 0.05 }, // Top-left
                { x: w * 0.85, y: h * 0.05 }, // Top-right
                { x: 0, y: h },               // Bottom-left
                { x: w, y: h },               // Bottom-right
            ];

            const transformMatrix = getPerspectiveTransform(srcPoints, dstPoints.map(p => ({
                x: p.x * originalWidth / w,
                y: p.y * originalHeight / h
            })));
            
            const invMatrix = invertMatrix(transformMatrix);
            
            if (!invMatrix) {
                console.error("Matrix is not invertible.");
                return;
            }

            const imageData = ctxTransformed.createImageData(w, h);
            const data = imageData.data;
            
            const originalCtx = document.createElement('canvas').getContext('2d');
            originalCtx.canvas.width = originalWidth;
            originalCtx.canvas.height = originalHeight;
            originalCtx.drawImage(img, 0, 0, originalWidth, originalHeight);
            const originalImageData = originalCtx.getImageData(0, 0, originalWidth, originalHeight).data;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const transformedPoint = applyTransform(x, y, invMatrix);
                    if (!transformedPoint) continue;
                    const [srcX, srcY] = transformedPoint;
                    
                    if (srcX >= 0 && srcX < originalWidth && srcY >= 0 && srcY < originalHeight) {
                        // Using bilinear interpolation for better quality
                        const x0 = Math.floor(srcX);
                        const y0 = Math.floor(srcY);
                        const x1 = Math.min(x0 + 1, originalWidth - 1);
                        const y1 = Math.min(y0 + 1, originalHeight - 1);

                        const dx = srcX - x0;
                        const dy = srcY - y0;

                        const index = (y * w + x) * 4;

                        for (let c = 0; c < 4; c++) { // Iterate over R, G, B, A
                            const p00 = originalImageData[(y0 * originalWidth + x0) * 4 + c];
                            const p10 = originalImageData[(y0 * originalWidth + x1) * 4 + c];
                            const p01 = originalImageData[(y1 * originalWidth + x0) * 4 + c];
                            const p11 = originalImageData[(y1 * originalWidth + x1) * 4 + c];

                            const val = p00 * (1 - dx) * (1 - dy) + p10 * dx * (1 - dy) + p01 * (1 - dx) * dy + p11 * dx * dy;
                            data[index + c] = val;
                        }
                    }
                }
            }
            ctxTransformed.putImageData(imageData, 0, 0);
        }

        /**
         * Applies a transformation matrix to a point (x, y).
         */
        function applyTransform(x, y, matrix) {
            const [a, b, c, d, e, f, g, h, i] = matrix;
            const denominator = g * x + h * y + i;
            if (denominator === 0) return null;
            const newX = (a * x + b * y + c) / denominator;
            const newY = (d * x + e * y + f) / denominator;
            return [newX, newY];
        }

        /**
         * Calculates the perspective transformation matrix.
         */
        function getPerspectiveTransform(src, dst) {
            const A = [];
            for (let i = 0; i < 4; i++) {
                A.push([src[i].x, src[i].y, 1, 0, 0, 0, -src[i].x * dst[i].x, -src[i].y * dst[i].x]);
                A.push([0, 0, 0, src[i].x, src[i].y, 1, -src[i].x * dst[i].y, -src[i].y * dst[i].y]);
            }

            const b = [];
            for (let i = 0; i < 4; i++) {
                b.push(dst[i].x);
                b.push(dst[i].y);
            }
            
            const h = gaussianElimination(A, b);
            return [h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], 1];
        }

        /**
         * Solves a system of linear equations using Gaussian elimination.
         */
        function gaussianElimination(A, b) {
            const n = A.length;
            for (let i = 0; i < n; i++) {
                let maxEl = Math.abs(A[i][i]);
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(A[k][i]) > maxEl) {
                        maxEl = Math.abs(A[k][i]);
                        maxRow = k;
                    }
                }

                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [b[i], b[maxRow]] = [b[maxRow], b[i]];

                for (let k = i + 1; k < n; k++) {
                    const c = -A[k][i] / A[i][i];
                    for (let j = i; j < n; j++) {
                        if (i === j) A[k][j] = 0;
                        else A[k][j] += c * A[i][j];
                    }
                    b[k] += c * b[i];
                }
            }

            const x = new Array(n);
            for (let i = n - 1; i > -1; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) {
                    sum += A[i][j] * x[j];
                }
                x[i] = (b[i] - sum) / A[i][i];
            }
            return x;
        }

        /**
         * Inverts a 3x3 matrix.
         */
        function invertMatrix(m) {
            const [a, b, c, d, e, f, g, h, i] = m;
            const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
            if (det === 0) return null;

            const invDet = 1 / det;
            return [
                (e * i - f * h) * invDet, (c * h - b * i) * invDet, (b * f - c * e) * invDet,
                (f * g - d * i) * invDet, (a * i - c * g) * invDet, (c * d - a * f) * invDet,
                (d * h - e * g) * invDet, (b * g - a * h) * invDet, (a * e - b * d) * invDet
            ];
        }
    </script>
</body>
</html>
